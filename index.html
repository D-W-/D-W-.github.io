
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>D W</title>
  <meta name="author" content="Harry">

  
  <meta name="description" content="前言 最近在读侯捷老师的《STL源码剖析》一书，收获简直太大。一激动就想把学的东西赶紧记下来写篇博客，然后想到我以前的博客系统，bug无穷，于是决定亲自配一个Octopress的博客，因为之前的博客是Jekyll的，博文都用的markdown写的，Octopress也是markdown语法， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://d-w-.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="D W" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><div class="header-left">
  <hgroup>
  <h1><a href="/">D W</a></h1>
  
  <div class="subtitle">
    <h2>Brick walls are there for a reason, they let us prove how badly we want things.</h2>
  </div>
  
  </hgroup>
  
</div>

<div class="header-right">
  <ul class="main-navigation">
 <div class="selected"> 
  <li><a href="/">blog</a></li></div><div class="spacer"></div>
     <div> 
  <li><a href="/projects">projects</a></li></div><div class="spacer"></div>
       <div> 
  <li><a href="/work">work</a></li></div><div class="spacer"></div>
         <div> 
  <li><a href="/about">about</a></li></div>
</ul>
  

</div>
</header>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/04/moving-my-blog-to-octopress/">Moving My Blog to Octopress</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-04-04T21:34:53+00:00" pubdate data-updated="true"></time>
        
        
           | <a href="/blog/2015/04/04/moving-my-blog-to-octopress/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>前言</h2>

<p>最近在读侯捷老师的《STL源码剖析》一书，收获简直太大。一激动就想把学的东西赶紧记下来写篇博客，然后想到我以前的博客系统，bug无穷，于是决定亲自配一个Octopress的博客，因为之前的博客是Jekyll的，博文都用的markdown写的，Octopress也是markdown语法，这样可以直接连文字带样式轻松移植过来，想的挺轻松，但是实际操纵起来简直折腾了我好几天。。</p>

<p>在octopress上面搭建博客的过程真的是一波三折，由于原来简介的jekell模板有点问题，我决定把自己亲手重新装一个octopress的博客</p>

<h2>双系统的问题</h2>

<p>首先，由于双系统，我希望我能在任何一个系统上面写博客并同时push到github上面，由于octopress博客写完博客需要生成一下，我就不得不在两个系统上都装上生成博客需要的ruby环境和javascript环境。</p>

<p>装ruby的一些包时候遇到了一些问题，由于GRW的问题，直接从远程仓库安装安装不了，这时候需要借助<a href="http://ruby.taobao.org/">淘宝搭建的一个国内的仓库</a>，15min一更新还是很快的</p>

<p>使用如下的命令就可以了</p>

<pre><code>$ gem sources --remove https://rubygems.org/
$ gem sources -a https://ruby.taobao.org/
$ gem sources -l
*** CURRENT SOURCES ***

https://ruby.taobao.org
# 请确保只有 ruby.taobao.org
$ gem install rails
</code></pre>

<h2>博客主题的选择</h2>

<p>octopress对于主题的安装还是很简便的，调了一番，终于找了个比较中意的主题
<a href="https://github.com/martinbmadsen/classic-martinb.git">classic-martinb</a></p>

<pre><code>$ cd octopress
$ git submodule add git://github.com/fapper/classic-martinb.git .themes/classic-martinb
$ rake install['classic-martinb']
$ rake generate
</code></pre>

<h2>linux下面我的博客无法找到</h2>

<p>不知道什么原因，我的博客在linux的系统（包括我的ubuntu系统和安卓手机）的浏览器上面加载不到。。
后来我发现，我的博客域名是d-w-.github.io，在linux下面ping都无法ping通，应该是三级域名结尾是 - 的原因，我试了一下，只要结尾不是 - ，都可以ping的通。。这个问题还等后续解决，比如买个域名撘过来。。我甚至想把github的用户名给换了</p>

<h2>更改了主题或者更新了博客后 <code>rake deploy</code> 的push被rejecte</h2>

<p>这个问题一直出现，在stackoverflow上面有各式各样的解答，都可以起到作用，但是我每次deploy都要按照上面的方法执行一遍岂不是太麻烦了。。我观察了一下，原因应该是远程分支有两个，git并不知道push到哪一个的原因，又看了一下octopress的文档，有这么一句</p>

<blockquote><p>Note: With new repositories, Github sets the default branch based on the branch you push first, and it looks there for the generated site content. If you&rsquo;re having trouble getting Github to publish your site, go to the admin panel for your repository and make sure that the master branch is the default branch.</p></blockquote>

<p>看来只要master branch设为了默认分支就好了，这个是不是合适的解决方案还待后续检验。
后来经过我无数次删除repo，重装的循环，终于发现了原因。。是因为windows和Linux的换行符不一样，比如我在Linux下面初始化了一个repo，换行符是LF，然后我到了windows系统下面打开了这个项目目录，想去push，但是windows上面换行符是CRLF，这时候和远程的仓库比对，发现换行符不同。。就会被rejecte，因为git不知道用哪个好。。解决的办法在stack overflow上找到了，<a href="http://stackoverflow.com/questions/1967370/git-replacing-lf-with-crlf">只要改一下配置就好</a>，看来git确实强大。</p>

<h2>git的SSH验证和HTTPS验证</h2>

<p>由于端口的问题，我这边并没有开SSH的端口，都是采用HTTPS验证，在windows端可以直接用github的桌面版，push起来也挺轻松，但是在linux端，由于是HTTPS验证，每次push都要输入用户名和密码，这个问题待解决。</p>

<h2>对第三方主题进行更改</h2>

<p>既然折腾了就要折腾到底，单纯clone一个别人写好的主题显然不能满足我的要求，毕竟我以前的博客就有一些不错的特技。所以要对fork过来的第三方主题进行改装，来到 .theme 文件夹下面的相应的主题包里面，进行需要的修改，这里需要注意的就是修改结束之后需要再</p>

<pre><code>rake install[name]
</code></pre>

<p>一下，这样所做的修改才会生效</p>

<h2>添加多说评论系统</h2>

<p>这个比较简单，参照了<a href="http://havee.me/internet/2013-02/add-duoshuo-commemt-system-into-octopress.html">为 Octopress 添加多说评论系统</a>这篇文章，需要注意的一点是文章需要在前面的yml上面注明 <code>comments: true</code> 。</p>

<h2>在文章中添加本地图片</h2>

<p>这个是因为我用了泰然网上的两个图片，没想到有防盗链。。只能下载到本地才能正常显示，当然我在文章里面注明了图片的出处，个人认为这种防盗链确实没什么必要。。
参照<a href="http://blog.csdn.net/hankai1024/article/details/12833423">Octopress在页面和内容中加入代码、图片、带标题图片方法</a>
图片放到 <code>octopress\source\images</code> 里面
通过</p>

<pre><code>    r'&lt;img src="/images/pic_name.png"&gt;'
</code></pre>

<p>引用就可以了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/25/Monster-Storm/">Monster Storm</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-25T00:00:00-01:00" pubdate data-updated="true"></time>
        
        
           | <a href="/blog/2015/03/25/Monster-Storm/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Monster Storm</p>

<p>边学边写的cocos2d-x游戏,基于3.0版本</p>

<p>这个游戏的主要难点有两个
1. 怎么把所有需要消除的精灵摆对位置
2. 怎么找到某个精灵周围的同类精灵</p>

<h2>摆放精灵</h2>

<ol>
<li>找到精灵摆放点的左下角的(x,y)坐标,这里直接借用<a href="http://www.tairan.com/archives/5929">泰然网教程上说的</a></li>
</ol>


<blockquote><p><img src="/images/1.png"></p></blockquote>

<p>m_matrixLeftBottomX的值 ＝ （ 屏幕的宽 － 寿司的宽＊N个寿司 － （ N-1 ）＊寿司之间的间隙） ／ 2。</p>

<ol>
<li>从下到上,从左到右遍历整个matrix,为每个精灵编号,例如,左下角的精灵行号0,列号0……这样每个精灵都有了一个坐标,而每个坐标对应了屏幕上的一个位置,只需要根据左下角的坐标加加减减就可以得到某个坐标对应的具体位置,这样就建立了坐标和精灵,坐标和图上的位置分别以一对应的关系.</li>
<li>有了上面一一对应的关系,只要在对应位置的上空XX米创建出来精灵,并把它移到对应位置就可以了</li>
</ol>


<h2>查找并消除精灵</h2>

<ol>
<li>定位到用户点击的精灵,想完成消灭小星星的消除,首先要知道用户点了那个精灵,这里我当时写的算法很low,是先获取用户点击的坐标,然后遍历整个精灵matrix,看一下哪个精灵所在的square包含了那个坐标就是点击的坐标,当然,已经被消除了的精灵是不在那个matrix里面的;

<ul>
<li>比较好的一个做法应该是根据点击的坐标和左下角的距离关系直接找出对应的位置,然后检查该位置是否有精灵..</li>
</ul>
</li>
<li>定位完了就要找该精灵周边同类的精灵了,寻找过程类似于深度优先遍历,我是用递归写的,比如对于定位到的精灵,分别找它上下左右的精灵,如果上下左右的精灵是同类的话,就加入list,并更新上下左右的精灵为当前的精灵,继续递归查找上下左右.注意:查找的过程要注意重复,每次找到新的都要判断一下是否已经找过当前精灵..

<ul>
<li>当前另一个想法是类似于广度优先遍历,,用一个队列来维护,广度优先的好处是避免了递归</li>
</ul>
</li>
<li>然后要判断一下用户的第二次点击,点击的是不是第一次点的那个区域,判断的方法就是得到第二次点击的精灵(的地址),和已经存到list(第一次点击之后的所有同类精灵)里面的所有精灵进行比较,如果有相同的,则True,不是就False,清空list,blabla&hellip;</li>
<li>点击完了,也消除完了相应的精灵,要完成上面精灵的下落和精灵列的左移,这在<a href="http://www.tairan.com/archives/5929">泰然教程</a>上面说的很清楚</li>
</ol>


<blockquote><p><img src="/images/2.png"></p></blockquote>

<p>注意由于游戏不同,这里只有过程一,也就是不必填充,只让上面的下落:对于每一列从下到上查找空白数,等到了空白数大于0就说明精灵要下落了</p>

<blockquote><pre><code>  // 从下向上
    for (int row = 0; row &lt; m_height; row++) {
        sushi = m_matrix[row * m_width + col];
        if (NULL == sushi) {
            removedSushiOfCol++;
        } else {
            if (removedSushiOfCol &gt; 0) {
                //计算寿司精灵的新行数
                }
        }
    }
</code></pre></blockquote>

<p>让精灵列左移也是,从左到右,只要检查每列的第一个元素是否为NULL即可,然后整列左移</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/23/Review_Vcool-Website/">Review VCool Website</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-23T00:00:00-01:00" pubdate data-updated="true"></time>
        
        
           | <a href="/blog/2015/03/23/Review_Vcool-Website/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>以前做过的一些东西的简单回顾，避免面试官问起来都忘了，也能在简历上面写得更加得心应手</p>

<h2>python web.py 网站</h2>

<p>接入新浪微博SDK，通过向新浪微博提供的接口(网址)发送GET请求(包含uid和code)得到json格式的返回数据</p>

<p>通过新浪SDK获取需要的信息的步骤</p>

<ol>
<li>用户登陆我的网站,点击新浪微博登陆,调到新浪的登陆页面,其中附带有GET的参数 <strong>redirect_uri</strong> ,用于下一步跳回我的网站</li>
<li>登陆成功返回我的网站,同时带有GET参数code&hellip;</li>
<li>我用code通过POST方法向新浪申请token,新浪返回一个json格式的数据,里面有token</li>
</ol>


<p>基本上面三个总结成一句话,我通过和新浪协商好的token向新浪指定的接口(网站)请求我想要的信息</p>

<p><strong>实际上,向新浪微博API请求微博等服务的时候只有<strong>access_token</strong>这一个参数是必须的,并不需要用户名等其他参数</strong></p>

<p>每次都让用户登录一下执行上面的步骤太麻烦,所以必须把token存起来,每次要用的时候直接通过token向接口请求就好了,token使用cookie保存,存在用户端,是我加密好了的值,我在数据库存另存一份用于比对,用户每次登录我就向用户的浏览器请求token(web.cookies().get()),解密之后得到里面的用户id和存好的token就可以向客户端请求了.</p>

<p>有了上面这些基础知识,就可以详细的理解整个网站的处理流程了</p>

<ol>
<li>用户访问VCool主页,由index这个类的GET()方法处理,首先向浏览器请求cookie,如果得到了cookie,直接跳到第3步,没有cookie,执行第2步</li>
<li>用户的浏览器并没有保存cookie,只能给他看主页,等他点击&#8221;通过新浪微博登陆&#8221;的按钮进行登录,等他在新浪端登陆完了,回来之后的处理是由callback类进行处理的(就是上面所说的给新浪登陆页面提供的 <strong>redirect_uri</strong> 填的是&#8217;<a href="http://1.vcoool.sinaapp.com/callback">http://1.vcoool.sinaapp.com/callback</a>&#8217;)</li>
<li>这种情况是用户的浏览器保存了cookie,按理说可以直接<code>raise web.seeother(\callback)</code>交给callback处理,因为callback是专门处理登陆后流程的类,但是这样的话会显示<strong>此网页包含重定向循环</strong>,我也不知道为啥..所以进行下列处理

<ol>
<li>通过在cookie里面解码出来的access_token构建一个请求对象</li>
<li>调用新浪微博API请求用户所关注用户的最新50条微博</li>
<li>对API返回的json格式数据处理(因为返回的东西有很多,我们只需要有限的信息比如微博内容,图片,作者等..)
4 .使用已经保存到数据库的SVM函数(在callback中已经保存,因为这里浏览器都存了cookie,所以之前肯定已经登录过了)计算得到分类的权值,并进行排序</li>
<li>字符串处理,因为新浪API返回的是raw字符串,@,##,和链接都不会显示,这里进行正则替换,把他们转换成HTML超链接形式</li>
<li>把排好序的微博列表通过<code>render.list()</code>方法传入前端模板</li>
</ol>
</li>
</ol>


<p>callback对象的功能</p>

<p>callback对象是对用户第一次登陆VCool进行处理,就像上面说的,用户在新浪的登陆页面登陆结束后就会redirect到这个函数来处理,同时会用GET方法附带一个code参数,用于我们请求access_token</p>

<ol>
<li>接收GET过来的code参数值,没有的话跳转到首页&#8221;/&#8221;</li>
<li>通过code向新浪请求参数access_token,expires_in,uid,分别是调用API时要用到的参数,过期时间,登录用户的新浪ID</li>
<li>根据上面得到的uid(新浪ID)查询一下数据库,如果已经有了相应的项的话就进行更新,如果没有的话就新建一个列表项</li>
<li>存cookie,把得到的access_token和expired_in等信息加密存一下cookie,以便下一次使用</li>
<li>后面的功能和3.2-3.6一样了</li>
</ol>


<p>当前数据库:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>data(weibo_id,reposts,comments,attitudes,text,pic_urls)
</span><span class='line'>    用户喜欢的微博训练集(把用户评论过的微博当做训练集)
</span><span class='line'>dislike(weibo_id,reposts,comments,attitudes,text,pic_urls)
</span><span class='line'>    用户不喜欢的微博训练集(把用户删除的微博当做训练集)
</span><span class='line'>func(weibo_id   a1  a2  a3  a4  a5  b)
</span><span class='line'>    SVM得到的超平面公式
</span><span class='line'>user(weixin_id,weibo_id,access_token,expires_in)
</span><span class='line'>    存储微博账号对应的微信号,连接微博api需要的access_token</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/22/Morris-Traversal/">Morris Traversal</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-22T00:00:00-01:00" pubdate data-updated="true"></time>
        
        
           | <a href="/blog/2015/03/22/Morris-Traversal/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Morris Traversal 是深度优先遍历二叉树的一种方法,空间复杂度只要O(1),时间复杂度也只有O(n)
这里根据<a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html">博客园上的文章</a>进行了学习.整个算法我感觉主要有两部分不太容易懂 ,一是具体的算法部分,也就是如何利用线索二叉树找前驱节点的方法的;另一个就是如何证明这个算法是O(n)的.对于第一部分可以在代码里面说明,这里先说一下第二部分,借用原文中的话:</p>

<blockquote><p>直觉上，认为它的复杂度是O(nlgn)，因为找单个节点的前驱节点与树的高度有关。但事实上，寻找所有节点的前驱节点只需要O(n)时间。n个节点的二叉树中一共有n-1条边，整个过程中每条边<strong>最多只走2次</strong>，一次是为了定位到某个节点，另一次是为了寻找上面某个节点的前驱节点，如下图所示，其中红色是为了定位到某个节点，黑色线是为了找到前驱节点。所以复杂度为O(n)。
<img src="http://images.cnitblog.com/blog/300640/201306/15150628-5285f29bab234750a62e2309394b6e14.jpg" alt="此处输入图片的描述" /></p></blockquote>

<p>原文在这里讲的已经很详细了,这里补充一点,我感觉每条边并不是最多只会被走两次,而是最多会走3次,因为找前驱结点的话会走两次,a:第一次遍历到该节点,找到它的前驱节点,并把前驱节点的右孩子设为当前节点;b:第二次遍历到该节点,找到它的前驱结点,这时前驱结点的右孩子是当前节点(形成了一个环),这时把前驱结点恢复成NULL,并设置当前孩子的右孩子为当前节点.</p>

<p>这里我用python实现了一下<strong>中序遍历</strong></p>

<pre><code>#!/usr/bin/env python
#coding:utf-8

# Morris traversal
# O(1) space O(n) time

# 算法基本思想:类似于线索二叉树,找到每个节点的前驱节点,并用前驱节点的右孩子指向当前节点,最后再把该指针删除

'''算法步骤
1. 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。

2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。

   a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。

   b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。

3. 重复以上1、2直到当前节点为空。
'''

# 二叉树
class TreeNode:
    def __init__(self,x):
        self.val = x
        self.left = None
        self.right = None

class MorrisTraversal:
    '只是一个封装类,把各种遍历封装起来'
    @staticmethod
    def inOrder(root):
        now = root
        while now:
            if now.left == None:
                print now.val
                now = now.right
            else:
                pre = now.left
                # 寻找前驱,当第二次寻找now的时候now的前驱的right已经被设定成了now,也就是成了一个环,要注意,这里用 pre.right != now 来避免
                # 左边的最右就是前驱
                while pre.right and pre.right != now:
                    pre = pre.right
                if pre.right == now:
                    pre.right = None
                    print now.val
                    now = now.right
                else:
                    pre.right = now
                    now = now.left

if __name__ == '__main__':
    t1 = TreeNode(1)
    t2 = TreeNode(2)
    t3 = TreeNode(3)
    t4 = TreeNode(4)
    t5 = TreeNode(5)
    t6 = TreeNode(6)
    t7 = TreeNode(7)

    t1.left = t2
    t1.right = t3
    t2.left = t4
    t2.right = t5
    t3.left = t6
    t3.right = t7

    MorrisTraversal.inOrder(t1)
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/20/douban-paper-test/">豆瓣笔试</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-20T00:00:00-01:00" pubdate data-updated="true"></time>
        
        
           | <a href="/blog/2015/03/20/douban-paper-test/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>背景</h2>

<p>大三上是软院的找实习季,最近跟风投了几家公司,主要还是想看看自己实力如何,毕竟如果只呆在某个地方会使自我感觉良好.
前面已经被阿里面过,一面就跪了..面试官只问了两个问题,是两个项目的问题,一个是大二写的微信平台,我讲到一半就不让讲了,确切的说是当我讲到用PHP写的之后,后来开始问我会不会IOS,原来他把cocos2d-x引擎当成IOS开发了,之后大概他就感觉没什么可以和我聊的了直接结束了.一开始以为是问算法和基础知识,准备了挺长时间,也紧张了挺长时间..但是没被问到,算是一点遗憾吧,毕竟一些基础我自我感觉还是不错的</p>

<p>之后觉得项目实在是我的弱点,一是跟面试官聊天太紧张,二是老是不能get到面试官想问的点,比如如果和阿里的面试官聊微信平台的时候如果直接说到正则表达式的话估计也不会这么快就没得聊..当然最重要的是以前做的东西我都忘得差不多了,边想边说肯定不行,所以最近计划把之前做的东西再看一遍,借此复习,并完善一下简历.</p>

<h2>豆瓣笔试</h2>

<p>笔试在下午两点半,在线笔试,这也是我人生第一场笔试,不过估计不久就会有一大波(明天就有去哪儿网的笔试..).笔试之前得到了一个不幸的消息,我们微软创新杯的作品没有通过校赛的选拔,这个东西我们工作量虽然不大,但是也是忙里忙外做了两周,心有不甘.我去问负责人,他说一共要6个我们排在第7,具体评分也没有,再加上负责人自己也参赛了,并且是拿着去年获过奖的作品二次开发,由于他就在我隔壁,我也得知他在提交的前一天才开始二次开发..所以一直比较郁闷</p>

<p>然后就直接去笔试了,前两道题挺简单
 1. 第一个是写一个正则表达式匹配出来@链接,题目要求比较低,匹配字母数字下划线就行,我个人觉得应该是<code>'@[^:]+'</code>这样最好,就是匹配非空格,非冒号
 2. 第二个是简答题,设计模式.
 3. 第三题也比较简单,但是有个坑,由于前面两个我浪费太多时间了,做这题的时候有点着急,并没对输入进行异常处理..
 4. 第四个就有点难度了,找出一个矩阵中不同行不同列的元素和的最大值,我想了一会感觉和N皇后类似,而且前两天刚做过,就准备打开前两天的代码改一下就行..当我打开自己之前写代码的时候感觉坑了..自己写的这代码可读性太差了,还没有注释,虽然当时通过了OJ,但是急忙修改了一下填上了
 5. 第五个是数据库设计,我把数据库建表的语句忘得差不多了,就简单写了下思路,估计跪了
 6. 第六个是大数据,1000万数据中找出出现次数前十,我基本不会,就写了下数据量小的时候的思路(hash加最大堆)</p>

<p>做到最后感觉自己真的很弱,做过的项目都是小项目,写的代码可读性并不好,忘性大还不复习,槽点太多..还是应该把现在最弱的自己记录下来,引以为戒,多加学习~</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/20/Distinct-Subsequences/">LeetCode上面的Distinct Subsequences总结</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-20T00:00:00-01:00" pubdate data-updated="true"></time>
        
        
           | <a href="/blog/2014/12/20/Distinct-Subsequences/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近做了挺多东西,从中也学了不少,觉得总结一下比较好,一直没有时间就一直拖着,现在终于有点空闲的时间,觉得像我这种记性不太好的人还是多做一些code review,否则做一点忘一点,最后反而学不到什么东西.</p>

<h2>0.先在这里记录一下要整理的东西</h2>

<p>1.模拟登陆与抓包(以模拟登陆新浪微博为主,还包括一些编码加密方式)
2.简易python框架的使用和编写(参照<a href="http://www.liaoxuefeng.com/">廖雪峰的博客</a>)
3.cookie和session的区别
4.支持向量机学习笔记
5.图片分类算法(图像处理课堂作业总结)
6.一些在LeetCode上面做过的题目的总结</p>

<p>还是先回归正题,以后有空了再把那几个坑填上..
先总结一下今天做的这道题,LeetCode上面的<a href="https://oj.leetcode.com/problems/distinct-subsequences/">Distinct Subsequences</a></p>

<h2>1.题目描述</h2>

<p>首先这道题题目描述不是很容易理解,我看了半天还是没明白题意,可能是英语水平有限.这里重新描述一下这道题</p>

<p>给两个字符串S,T 要求在S中找子串(subsequence),使S的子串等于T,在S中找到最多的这样的子串个数</p>

<h2>2.解题思路</h2>

<p>这道题很明显是一道DP,作为一个初学者,我首先想到了最长公共子串</p>

<pre><code>    if(s1[i] == s2[i])
        dp[i][j] = dp[i-1][j-1]+1;
    else
        dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
</code></pre>

<p>可惜和这题没什么关系
DP很重要的是观察前后元素的关系,在这道题目中,如果用M*N的space来存储计算结果,其中<strong>dp[i][j]</strong>代表了<strong>T[0,i]</strong>中包含的等于<strong>T[0,j]</strong>的子串的数目.
重点就是得到<strong>dp[i][j]</strong>和前面的值之间的关系,我就先画了一张二维数组的表
r a b b b i t
0 0 0 0 0 0 0 0
r 0 1 1 1 1 1 1 1
a 0 0 1 1 1 1 1 1
b 0 0 0 1 2 3 3 3
b 0 0 0 0 1 3 3 3
i 0 0 0 0 0 0 3 1
t 0 0 0 0 0 0 0 3
表中的数值都是人工计算出来的,这里的重点是<strong>b重复了3次的那个地方</strong>,再找个重复多次的例子看了一下,发现了规律,(对于一个初学者直接写出递推式实在太困难,这样找规律的方法更容易理解一些)</p>

<pre><code>    if(s[i] == t[j])
        dp[i][j] = dp[i][j-1]+dp[i-1][j-1];
    else
        dp[i][j] = dp[i][j-1];
</code></pre>

<p>这些代码的<strong>数学解释</strong>就是:
当s[i]和t[j]匹配的时候
对应的值就是以s[i]结尾的子串的个数和不以s[i]结尾的子串的个数的和
例如rabb<strong>b</strong> 和 rab<strong>b</strong>匹配到最后一个b的时候,对应的值就是rabbb中以最后一个b结尾的还要和<strong>rab</strong>相等的子串的个数为2(123,124),不以最后一个b结尾的还要和<strong>rabb</strong>相等的子串的个数为1(1234),总和就是3,具体可以再用rabbbbbb和rabb匹配实验一下&hellip;
当不匹配的时候
直接等于上一个就好了..</p>

<h2>3.代码实现</h2>

<pre><code>    class Solution {
    public:
        int numDistinct(string S, string T) {
            //DP
            /*dp[i][j] stores  number of S[0,i]'s substr which equals T[0,j]*/
            int **dp = new int*[T.length()+1];
            for (int i = 0; i &lt;= T.length(); ++i){
                dp[i] = new int[S.length()+1];
                memset(dp[i], 0, sizeof(int)*S.length());
            }
            for (int i = 0; i &lt;= S.length(); ++i)
                dp[0][i] = 1;
            bool flag = false;
            int next = 0;
            for (int i = 0; i &lt; T.length(); ++i){
                for (int j = next; j &lt; S.length(); ++j){
                    if (S[j] == T[i]){
                        dp[i + 1][j + 1] = dp[i][j] + dp[i + 1][j];
                        if (!flag){
                            flag = true;
                            next = j + 1;
                        }
                    }
                    else
                        dp[i + 1][j + 1] = dp[i + 1][j];
                }
                flag = false;
            }
            return dp[T.length()][S.length()];
        }
    };
</code></pre>

<h2>3.代码优化</h2>

<p>0.我的代码一开始有一个比较大的问题,就是没对数组初始化..后来进行了修改</p>

<ol>
<li><p>内层循环的开始不必是0,这点我已经在实现的时候优化,
比如rabbbit和rabbit匹配的时候匹配到了t的时候,只要从(rabbit中的)i的下一个开始匹配就可以了,因为要匹配t,必须在前面所有字符已经匹配结束的基础上匹配t</p></li>
<li><p>比较重要的一个优化,leetcode论坛上面一个大牛的优化,将空间复杂度降到了O(n)</p></li>
</ol>


<p>具体是这样的</p>

<pre><code>    vector&lt;int&gt; path(m+1, 0);
    path[0] = 1;            // initial condition

    for (int j = 1; j &lt;= n; j++) {
        // traversing backwards so we are using path[i-1] from last time step
        for (int i = m; i &gt;= 1; i--) {
            path[i] = path[i] + (T[i-1] == S[j-1] ? path[i-1] : 0);
        }
    }
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/25/Word-Ladder/">LeetCode上面的WordLadder总结</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-25T00:00:00-01:00" pubdate data-updated="true"></time>
        
        
           | <a href="/blog/2014/11/25/Word-Ladder/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>按通过率来说,WordLadder应该是Leetcode上面最难的一道题了
其中的第二道我提交了8次才成功,多数原因是TLE,这实在令人沮丧</p>

<p>在此应该总结一下,强化自己的答题技巧</p>

<p><em>题目描述</em> :通过每次改变单词的一个字母,找到一个单词到另一个单词的最短通路</p>

<ol>
<li>核心算法BFS
 因为题目要求最短的路径,BFS将所有的结点分层,找到结尾单词(end)最先出现的
 层就是最短的路径</li>
<li>BFS分层
 BFS分层的方法有两种

<ol>
<li>在队列中插入分隔符, 每当取出一个分隔符的时候就在队列尾插入一个分隔符两个分隔符之间的结点都处于同一层</li>
<li>记录已经查找过的元素的层号, 找到合适的子结点的时候就把子结点的层号设为父节点的层号加1</li>
</ol>
</li>
<li>记录路径的方向, 防止无限循环
 防止 hot找到了dot, dot又找到了hot 这种无限循环问题

<ol>
<li>找到合适的子结点就把它在集合里面删掉因为当时考虑到如果一个字符串出现了一次,它的下一次出现肯定会比这一次出现造成的wordladder长(因为广度优先遍历,后面出现的元素层数大于等于前面出现的元素的层数)</li>
<li>找到了合适的子结点就标记一下, 增加一个查找标记数组的步骤
这两种方法有一个bug,详见第四条</li>
</ol>
</li>
<li>3中解决方法的bug 两个不同的结点有相同的后继(1中第一次出现就会把后继删掉了,2中第一次出现就把后继标记过了)

<ol>
<li>3.1的补救办法,将删除子结点的过程延迟到每一层结束的时候,每一层结束的时候统一在dict里面删除该层所有的子结点</li>
<li>将2.2和3.2结合,同时记录查找过的元素的内容和层号,存到一个unordered_map里面,找到合适的元素的时候看一下map里面是否存在了,如果存在了的话再比较层号,层号相同则新找到的路径也是合理的路径,记录下来</li>
</ol>
</li>
<li>WordLadderII要求记录所有最短路径,如何保存最短路径

<ol>
<li>BFS的时候一边找一边存,具体做法建立一个和BFS队列操作相同的队列,存储myqueue中当前元素所在的vector</li>
<li>BFS的过程中记录下每一条通路的边,保存起来,BFS结束之后再跑一遍DFS,通过DFS的递归可以轻易得到结果集</li>
</ol>
</li>
<li>5.2的优化,将所有通路的边倒序存储,DFS倒序遍历,可以砍掉很多不必要的结点(比如从start开始结果并不是end的那些边)</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/14/Linux-File-System/">Linux文件系统基础</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-14T00:00:00-01:00" pubdate data-updated="true"></time>
        
        
           | <a href="/blog/2014/11/14/Linux-File-System/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>鸟哥的Linux私房菜学习笔记(0)</h2>

<blockquote><p>这篇读书笔记本来计划用sublime写的</p>

<blockquote><p>无奈sublime对中文支持的太不好了,linux下居然不能中文输入,网上查了一下配置太麻烦,为了不浪费时间,只好下次再配吧</p></blockquote></blockquote>

<hr />

<hr />

<p>文件格式化:确定文件在硬盘中存储的格式,比如</p>

<p> Ext2文件</p>

<p>   super block</p>

<p>   记录整体信息,inode,block的总量 使用量</p>

<p>   inode</p>

<p>   一个文件对应一个inode,里面同时记录用于了存储文件内容的block号码</p>

<p>   block</p>

<p>   用于存储文件的内容,一个文件可能对应多个block</p>

<blockquote><p>和FAT文件格式的对比
FAT文件block的存储是串成一条链的,像链表一样,要找的文件的具体内容必须遍历这个链,存储分散的话复杂度比较高
Ext2文件的block编号都存在inode里面了,像数组一样,只要有inode的地址就可以轻松找到所有的文件内容</p></blockquote>

<h2>inode容量有限,如何存储较多的block编号</h2>

<p>分层,12个直接指向,1个间接指向(指向一个block,该block里面存的是其他block的编号),1个双间接指向,1个三间接指向</p>

<h2>Ext2用于目录</h2>

<p>inode记录文件夹(目录)的权限属性,以及文件夹(目录)对应的block编号
block记录<em>该目录下文件名和该文件名占用的inode号码数据</em>
    类似于这样,<code>map&lt;string,string&gt;</code>,前一个string是文件名,后一个是对应的<em>inode</em>编号</p>

<blockquote><p>可以解释文件夹(目录)的读权限
有了目录的读权限可以看到他block里面的东西,也就可以看到他里面的文件名,但是只限于文件名
如果进入文件夹的话还需要执行权限</p></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/15/First-Blog/">第一篇博客</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-15T00:00:00+00:00" pubdate data-updated="true"></time>
        
        
           | <a href="/blog/2014/10/15/First-Blog/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>我这个人，执行力很差。</h2>

<hr />

<p>很久之前，大约在大一下，我第一次听组长说有个人写了一个可以爬学生周知的东西。就很想写一个爬NBA比赛结果的东西，
当时只是想一想，因为感觉放在微信上的话会很方便，再加上当时刚刚接触编程，觉得什么都很难，这件事就搁置了。
后来我学会了一点网络爬虫，PHP，知道了一些简单的爬网页的知识，大二上的时候写了一个爬NBA比分的东西，后来基于
爬虫又弄了挺多东西。可是当时已经出现了一个叫做虎扑看球的东西。。。我知道了一点正则表达式匹配的东西就觉得自己
挺了解爬虫了，没有继续学习，直到现在我才发现爬东西不一定要正则表达式，python的一些包也可以爬东西。看到的
《python基础教程》一书里面就介绍了三种爬虫技巧。</p>

<p>回到博客，也是大一左右，偶然看到一篇东西说程序员写点博客挺好，当时心血来潮直接注册了一个博客园的博客。后来基本
没怎么动过。再后来看到了一个学长的博客，感觉界面挺好看的，觉得自己也应该弄个博客。网上一搜教程，看上去挺难的，
又搁置了。直到现在，发现弄一个博客原来很简单。</p>

<p>数不胜数的事情都因为我的放弃变得看上去很难。</p>

<p>开通这个博客，首先应当提醒自己坚持的重要性。</p>

<p>然后这是一个记录心情和经验的地方。偶尔停下来总结一下也挺好。</p>

<p>然后把最近的计划写一写，争取有计划有规律的学习。</p>

<p>希望能踏实学好算法，通过python再把网络编程熟悉一下。英语也不能拉下。毕竟钱都交了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/03/Hello-World/">Markdown Style Guide</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-03T00:00:00-01:00" pubdate data-updated="true"></time>
        
        
           | <a href="/blog/2014/03/03/Hello-World/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is a demo of all styled elements in Jekyll Now.</p>

<p><a href="https://raw.githubusercontent.com/barryclark/www.jekyllnow.com/gh-pages/_posts/2014-6-19-Markdown-Style-Guide.md">View the markdown used to create this post</a>.</p>

<p>This is a paragraph, it&rsquo;s surrounded by whitespace. Next up are some headers, they&rsquo;re heavily influenced by GitHub&rsquo;s markdown style.</p>

<h2>Header 2 (H1 is reserved for post titles)</h2>

<h3>Header 3</h3>

<h4>Header 4</h4>

<p>A link to <a href="http://github.com/barryclark/jekyll-now/">Jekyll Now</a>. A big ass literal link <a href="http://github.com/barryclark/jekyll-now/">http://github.com/barryclark/jekyll-now/</a></p>

<p>An image, located within /images</p>

<p><img src="/images/jekyll-logo.png" title="an image title" alt="an image alt text" /></p>

<ul>
<li>A bulletted list</li>
<li>alternative syntax 1</li>
<li><p>alternative syntax 2</p>

<ul>
<li>an indented list item</li>
</ul>
</li>
<li><p>An</p></li>
<li>ordered</li>
<li>list</li>
</ul>


<p>Inline markup styles:</p>

<ul>
<li><em>italics</em></li>
<li><strong>bold</strong></li>
<li><code>code()</code></li>
</ul>


<blockquote><p>Blockquote</p>

<blockquote><p>Nested Blockquote</p></blockquote></blockquote>

<p>Syntax highlighting can be used by wrapping your code in a liquid tag like so:</p>

<p>{% highlight javascript %}
/<em> Some pointless Javascript </em>/
var rawr = [&ldquo;r&rdquo;, &ldquo;a&rdquo;, &ldquo;w&rdquo;, &ldquo;r&rdquo;];
{% endhighlight %}</p>

<p>creates&hellip;</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/* Some pointless Javascript */</span>
<span class="kd">var</span> <span class="nx">rawr</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">];</span></code></pre></div>


<p>Use two trailing spaces
on the right
to create linebreak tags</p>

<p>Finally, horizontal lines</p>

<hr />

<hr />
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  <section>
  <h1><a href="#">Deadman walking</a></h1>
  <p>A nerd ,doing what I like, learning what I want.</p>
  <p>You can read more about me on my <a href="/about/">about</a> page. To see what I&#8217;m working on, check out my GitHub page <a href="https://github.com/D-W-">here</a>.</p>
  <div class="social-icons">
    

    

    

    

    

    <a href="/atom.xml"><img src="/images/social/rss.png" alt="RSS" /></a>
  </div>
</section>

  <section>
  <h1>Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/04/04/moving-my-blog-to-octopress/">Moving My Blog to Octopress</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/25/Monster-Storm/">Monster Storm</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/23/Review_Vcool-Website/">Review VCool Website</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/22/Morris-Traversal/">Morris Traversal</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/20/douban-paper-test/">豆瓣笔试</a>
      </li>
    
  </ul>
</section>

  
    




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Harry -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

<p>
<span class="credit">Powered by <a href="http://octopress.org">Octopress</a> using the <a href="https://github.com/fapper/classic-martinb">classic-martinb</a> theme</span>
</p>
</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
